# 1.4 Features of the Proposed Solution

## Justification of Computational Methods Used

### The Need for Computational Methods

Computational methods would be ideal to create my project for several reasons: 

* My project is a game which simulates platforming and death, which is obviously not possible in a real-life context, hence the need for a simulation via computational methods.
* The user’s high scores can easily be saved and displayed on the main menu, as a program could be run by the computer to collect data about the player’s current score, and output this for any user to see, making the user interface more accessible and friendly. 
* The player can easily control the events of the game, by using inputs on a controller/keyboard to make the character take certain actions ingame. This can be done by the computer constantly checking for inputs, and running the appropriate code to give the desired outcome. 
* The game could also follow certain rules that the player does not necessarily know, such as the fall speed, enemy health stat or other variables and functions. This creates a more immersive experience by allowing the computer to process all the required data behind the scenes of the game, so that the player does not have to worry about any complex algorithms, and focus on enjoying the game. 
* Graphical representation is needed for my project, as the game needs to have a visual output for the player to see, in order for them to actually understand what the game is like. Computational methods would be ideal for this, as the software could just update the graphical output every frame to express the effect of what the player is doing. This is essential for the representation of the player character, objects, enemies, the landscape and other sprites.

### Thinking Abstractly and Visualisation

Abstraction is the process of removing unnecessary details from a program. Only important and essential aspects of the game world would be implemented into my game. This would include:

* Weather should be abstracted away completely, as it has absolutely nothing to do with my game, as it occurs mostly within a closed room, so is unnecessary to develop. ● Graphics will be abstracted down to basic sprite, by using a pixel-art theme throughout the game, which would cut down time on aesthetic design by a considerable amount, as I am not sure I can create visually appealing graphics in the development time I have to create the game. 
* Stage layout will be simple, with only the floor, the walls and a few platforms actually having colliders to interact with the player character and the enemies, which means I can safely abstract away the background of the game as only aesthetics, meaning more development time spent on the more essential parts of my game. 
* Enemy behaviour will, via abstraction, use the technique of raycasting to search for the player character, and will likely use the A\* algorithm to calculate and take the shortest path to the player. This method is much quicker and viable than creating physical ‘eyes’ for every single enemy to search for the player character. 
* Rules relating to real life, such as fall damage, hunger and sleep, will not feature at all within my game, as I feel that their representation is useless within the boundaries of my game, as they detract from the experience and do not help in immersing the user into the action on screen.

### Thinking Ahead

In order to have a structured and organised approach to developing my game, I should outline the inputs and outputs needed for my game to run, as well as how they affect my game as a whole. 

For example, my inputs would include the WASD keys for movement and the SHIFT key for slashing with a sword. These inputs will remain consistent throughout the entirety of my game, and will not be affected at all as the game changes, providing an easy-to-use interface for the game’s user. Furthermore, outputs need to be specified early on, such as my player character’s position in the game world, and any values that the player needs to be aware of \(amount of currency, health etc.\), so that the user can understand what is going on in the game and how their inputs will affect the above.

### Thinking Procedurally & Decomposition

Decomposition is the process by which a larger, more complex task is broken down into more simple, easy-to-manage tasks. This is key in ensuring that I focus on one part of the game at a time, and completely finish one section of the code before starting to code another. Furthermore, some elements of my code \(eg. enemy deaths, increasing the amount of currency held\) will be the same, so I can bundle each of these into reusable program components, that I can use frequently throughout my code without wasting extra time rewriting each component, or making unnecessary errors that I could easily avoid.

### Thinking Logically

Throughout the course of the game, the player should be able to make free decisions about what action to take if multiple options are presented to them. The program must be able to make logical decisions to accommodate all choices the player makes throughout the course of the game, as well as making enemies react to the player’s presence, and keeping track of player stats in the background. The player will be presented with a variety of options to choose between as the game progresses.

* A player on the title screen should be able to decide what name they choose to save their progress under, which then displays their high score on a table in the title screen. The program must be able to accept all inputs for a name, and display the correct stored name as well as the relevant score that player got, as well as the total currency that player has accumulated.
* In the shop, the player will be able to buy certain upgrades for their character, of which more than one will be available at the same time, thus the program needs to be capable of handling any decisions made by the player in any order, and store these under the correct player.

The software itself must also be capable of making decisions regarding the game as it runs.

* The program should be constantly checking for valid external inputs from the game’s user \(eg. WASD keys to move, SHIFT to use the sword...\), and ignoring those that should not be accepted. 
* For the enemy movement, the program must be able to detect whether an enemy has ‘seen’ the player, and what actions it will take to move towards them. Whether or not to run a path algorithm to travel to the player character should depend on the distance between the player and the enemy, which the program should be constantly comparing while the game is active.

### Thinking Concurrently

When the game is running, several different tasks need to be carried out concurrently, meaning that multiple instructions are executed at the same time. This must be used for the following reasons:

* Sound effects need to coincide with the relevant interaction in-game \(eg. a slashing sound when the player’s sword is swung\), so as to quickly present the reader with easy-to-understand user feedback on what actions they have taken and create an environment closer to real life. 
* Player and enemy movement must occur at the same time in order to provide a more fluid and engaging player experience, as having the player and enemies taking turns to move would slow the game down significantly, which is not at all a desired outcome for a fast-paced game. To solve this, I could update sprite movement every frame, to simulate simultaneous movement

